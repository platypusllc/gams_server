
#ifndef   _THREAD_LOCALIZATION_H_
#define   _THREAD_LOCALIZATION_H_

#include <string>
#include <stdio.h>
#include <iostream>
#include <cmath>
#include <chrono>
#include <queue>
#include <mutex>
#include <vector>
#include <numeric>
#include <eigen3/Eigen/Core>
#include <eigen3/Eigen/LU>
#include <GeographicLib/GeoCoords.hpp>

#include "madara/threads/BaseThread.h"
#include "../datum.h"
#include "../boat_containers.h"
#include "../utility.h"

#define STATE_DIMENSION 6
#define MAX_MAHALANOBIS_DIST 6.0
#define MAX_DATA_QUEUE_SIZE 100

#define GPS_HISTORY_TIME_WINDOW 3 // x seconds long window of gps data used
#define GPS_HISTORY_REQUIRED_SIZE 6 // require at least x gps measurements before gps velocity can be calculated 

typedef Eigen::Matrix< double, STATE_DIMENSION, 1> StateMatrix;
typedef Eigen::Matrix< double, STATE_DIMENSION, STATE_DIMENSION> StateSizedSquareMatrix; 

namespace threads
{
  /**
  * A custom thread generated by gpc.pl
  **/
  class localization : public madara::threads::BaseThread
  {
  public:
    /**
     * Default constructor
     **/
    localization (Containers & containers);
    
    /**
     * Destructor
     **/
    virtual ~localization ();
    
    /**
      * Initializes thread with MADARA context
      * @param   context   context for querying current program state
      **/
    virtual void init (madara::knowledge::KnowledgeBase & knowledge);

    /**
      * Executes the main thread logic
      **/
    virtual void run (void);

    void new_sensor_update(const Datum & datum);

    /**
     * Set the localization and arm field once both GPS and compass are init
     **/
    void arm_and_set_localized (void);

    void update();

  private:
    void updateKB();
    void predict(double dt);
    void setH();    

    madara::knowledge::KnowledgeBase data_;
    Containers containers_;
    std::priority_queue<Datum, std::vector<Datum>, DatumComparison> data_queue;
    std::mutex queue_mutex;
    Datum current_datum;
    std::vector<double> eastingNorthingHeading;
    std::vector<double> location;
    std::vector<double> local_state;
    StateMatrix state;
    StateSizedSquareMatrix Q; // growth of uncertainty with time (after time step modification)
    StateSizedSquareMatrix QBase; // growth of uncertainty with time (before time step modification)
    StateSizedSquareMatrix P;
    StateSizedSquareMatrix G;
    StateSizedSquareMatrix Phi;
    StateSizedSquareMatrix Phi_k;
    Eigen::MatrixXd z;
    Eigen::MatrixXd R;
    Eigen::MatrixXd dz;
    Eigen::MatrixXd H;
    Eigen::MatrixXd S;
    Eigen::MatrixXd K;
    std::chrono::time_point<std::chrono::high_resolution_clock> t; // current time
    std::chrono::time_point<std::chrono::high_resolution_clock> t0; // reference time
    double tR; // current time, but measured relative to the reference time, in seconds
    double home_x;
    double home_y;  
    double heading;  
    GeographicLib::GeoCoords coord;
    
    std::vector<double> gps_data_t;
    std::vector<double> gps_data_x;
    std::vector<double> gps_data_y;
  };
} // end namespace threads

#endif // _THREAD_LOCALIZATION_H_
